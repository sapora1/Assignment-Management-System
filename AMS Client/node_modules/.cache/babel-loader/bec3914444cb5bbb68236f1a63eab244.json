{"ast":null,"code":"'use strict';\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nimport stringConverter from './converters/stringConverter';\nvar RADIX = 36;\n/**\n * @memberof module:compressed-json\n * @function decompress\n * @param {Object} compressed\n * @param {Object} [options={}] - Optional settings\n */\n\nfunction decompress(compressed) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$reservedKeys = options.reservedKeys,\n      reservedKeys = _options$reservedKeys === void 0 ? [] : _options$reservedKeys,\n      _options$reservedValu = options.reservedValues,\n      reservedValues = _options$reservedValu === void 0 ? [] : _options$reservedValu;\n\n  if (!compressed) {\n    return null;\n  }\n\n  var _compressed$K = compressed.K,\n      K = _compressed$K === void 0 ? [] : _compressed$K,\n      _compressed$P = compressed.P,\n      P = _compressed$P === void 0 ? [] : _compressed$P,\n      values = compressed._;\n  var keys = [].concat(_toConsumableArray(reservedKeys), _toConsumableArray(K));\n  var pointers = [].concat(_toConsumableArray(reservedValues), _toConsumableArray(P));\n\n  var stringValueFor = function stringValueFor(value) {\n    if (stringConverter.isPointer(value)) {\n      var index = parseInt(stringConverter.fromPointer(value), RADIX);\n      return pointers[index];\n    }\n\n    return stringConverter.fromEscaped(value);\n  };\n\n  var convert = function convert(values) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$keyPath = _ref.keyPath,\n        keyPath = _ref$keyPath === void 0 ? '' : _ref$keyPath;\n\n    if (Array.isArray(values)) {\n      return values.map(function (v, i) {\n        return convert(v, {\n          keyPath: [keyPath, i].join('/')\n        });\n      });\n    }\n\n    if (values === null) {\n      return null;\n    }\n\n    switch (_typeof(values)) {\n      case 'undefined':\n        {\n          return;\n        }\n\n      case 'function':\n        return null;\n\n      case 'object':\n        {\n          var decompressed = {};\n          var shortKeys = Object.keys(values);\n\n          for (var _i = 0, _shortKeys = shortKeys; _i < _shortKeys.length; _i++) {\n            var shortKey = _shortKeys[_i];\n            var value = values[shortKey];\n            var key = keys[parseInt(shortKey, RADIX)];\n            decompressed[key] = convert(value, {\n              keyPath: [keyPath, shortKey].join('/')\n            });\n          }\n\n          return decompressed;\n        }\n\n      case 'string':\n        return stringValueFor(values, keyPath);\n\n      default:\n        return values;\n    }\n  };\n\n  return convert(values);\n}\n\ndecompress.fromString = function decompressFromString(compressedString) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return decompress(JSON.parse(compressedString), options);\n};\n\nexport default decompress;","map":{"version":3,"sources":["C:\\Users\\rarya\\OneDrive\\Desktop\\git hashcode\\AMS\\AMS Client\\node_modules\\compressed-json\\lib\\decompress.js"],"names":["stringConverter","RADIX","options","reservedKeys","reservedValues","K","P","values","compressed","keys","pointers","stringValueFor","index","parseInt","convert","keyPath","Array","decompressed","shortKeys","Object","shortKey","value","key","decompress","JSON","module"],"mappings":"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","sourcesContent":["\n'use strict'\n\nconst stringConverter = require('./converters/stringConverter')\nconst RADIX = 36\n\n/**\n * @memberof module:compressed-json\n * @function decompress\n * @param {Object} compressed\n * @param {Object} [options={}] - Optional settings\n */\nfunction decompress (compressed, options = {}) {\n  const {\n    reservedKeys = [],\n    reservedValues = [],\n  } = options\n  if (!compressed) {\n    return null\n  }\n  const { K = [], P = [], _: values } = compressed\n  const keys = [...reservedKeys, ...K]\n  const pointers = [...reservedValues, ...P]\n  const stringValueFor = (value) => {\n    if (stringConverter.isPointer(value)) {\n      const index = parseInt(stringConverter.fromPointer(value), RADIX)\n      return pointers[index]\n    }\n    return stringConverter.fromEscaped(value)\n  }\n  const convert = (values, { keyPath = '' } = {}) => {\n    if (Array.isArray(values)) {\n      return values.map((v, i) => convert(v, { keyPath: [keyPath, i].join('/') }))\n    }\n    if (values === null) {\n      return null\n    }\n    switch (typeof values) {\n      case 'undefined': {\n        return\n      }\n      case 'function':\n        return null\n      case 'object': {\n        const decompressed = {}\n        const shortKeys = Object.keys(values)\n        for (const shortKey of shortKeys) {\n          const value = values[shortKey]\n          const key = keys[parseInt(shortKey, RADIX)]\n          decompressed[key] = convert(value, { keyPath: [keyPath, shortKey].join('/') })\n        }\n        return decompressed\n      }\n      case 'string':\n        return stringValueFor(values, keyPath)\n      default:\n        return values\n    }\n  }\n  return convert(values)\n}\n\ndecompress.fromString = function decompressFromString (compressedString,options={}) {\n  return decompress(JSON.parse(compressedString),options)\n}\n\nmodule.exports = decompress\n"]},"metadata":{},"sourceType":"module"}