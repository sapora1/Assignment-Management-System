{"ast":null,"code":"/**\n * @memberof module:compressed-json\n * @function compress\n * @param {Object} data\n * @param {Object} [options={}] - Optional settings\n */\n'use strict';\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nimport stringConverter from './converters/stringConverter';\n/** @lends module:compressed-json.compress */\n\nfunction compress(src) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$reservedKeys = options.reservedKeys,\n      reservedKeys = _options$reservedKeys === void 0 ? [] : _options$reservedKeys,\n      _options$reservedValu = options.reservedValues,\n      reservedValues = _options$reservedValu === void 0 ? [] : _options$reservedValu;\n  var MIN_SHARE_STRING_LENGTH = 4;\n  var MAX_SHARE_STRING_LENGTH = 512;\n  var keysDict = {};\n  var knownValuesDict = {};\n  var pointers = [];\n  var keys = [];\n  var wrappers = {};\n\n  var shortKeyFor = function shortKeyFor(key) {\n    if (key in keysDict) {\n      return keysDict[key];\n    }\n\n    var keyIndex = keys.length;\n    var shortKey = keyIndex.toString(36);\n    keysDict[key] = shortKey;\n    keys.push(key);\n    return shortKey;\n  };\n\n  reservedKeys.forEach(function (reservedKey) {\n    return shortKeyFor(reservedKey);\n  });\n\n  var stringValueFor = function stringValueFor(value, keyPath) {\n    var canBeShared = MIN_SHARE_STRING_LENGTH <= value.length && value.length <= MAX_SHARE_STRING_LENGTH;\n\n    if (canBeShared) {\n      if (value in knownValuesDict) {\n        if (knownValuesDict[value].shared) {\n          return knownValuesDict[value].pointer;\n        }\n\n        var index = pointers.length;\n        pointers.push(value);\n        var pointer = stringConverter.toPointer(index);\n        knownValuesDict[value].pointer = pointer;\n        knownValuesDict[value].shared = true;\n        return pointer;\n      }\n    }\n\n    knownValuesDict[value] = {\n      keyPath: keyPath,\n      shared: false,\n      pointer: null\n    };\n    return stringConverter.toEscaped(value);\n  };\n\n  reservedValues.forEach(function (reservedValue) {\n    return stringValueFor(reservedValue);\n  });\n\n  var convert = function convert(values) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$keyPath = _ref.keyPath,\n        keyPath = _ref$keyPath === void 0 ? '' : _ref$keyPath;\n\n    if (Array.isArray(values)) {\n      var arr = values.map(function (v, i) {\n        return convert(v, {\n          keyPath: [keyPath, i].join('/')\n        });\n      });\n      wrappers[keyPath] = arr;\n      return arr;\n    }\n\n    if (values === null) {\n      return null;\n    }\n\n    var type = _typeof(values);\n\n    switch (type) {\n      case 'function':\n        return null;\n\n      case 'object':\n        {\n          if (values instanceof Date) {\n            return values.toJSON();\n          }\n\n          var compressed = {};\n\n          var _keys = Object.keys(values);\n\n          for (var _i = 0, _keys2 = _keys; _i < _keys2.length; _i++) {\n            var key = _keys2[_i];\n            var value = values[key];\n            var shortKey = shortKeyFor(key);\n            compressed[shortKey] = convert(value, {\n              keyPath: [keyPath, shortKey].join('/')\n            });\n          }\n\n          wrappers[keyPath] = compressed;\n          return compressed;\n        }\n\n      case 'string':\n        return stringValueFor(values, keyPath);\n\n      default:\n        return values;\n    }\n  };\n\n  var converted = convert(src);\n\n  for (var _i2 = 0, _Object$values = Object.values(knownValuesDict); _i2 < _Object$values.length; _i2++) {\n    var _Object$values$_i = _Object$values[_i2],\n        pointer = _Object$values$_i.pointer,\n        shared = _Object$values$_i.shared,\n        keyPath = _Object$values$_i.keyPath;\n\n    if (shared && keyPath) {\n      var _keys3 = keyPath.split('/');\n\n      var lastKey = _keys3.pop();\n\n      var wrapper = wrappers[_keys3.join('/')];\n\n      wrapper[lastKey] = pointer;\n    }\n  }\n\n  var K = keys.slice(reservedKeys.length);\n  var P = pointers.slice(reservedValues.length);\n  return _objectSpread({}, K.length > 0 ? {\n    K: K\n  } : {}, {}, P.length > 0 ? {\n    P: P\n  } : {}, {\n    _: converted\n  });\n}\n\ncompress.toString = function compressToString(data) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var compressed = compress(data, options);\n  return JSON.stringify(compressed);\n};\n\nexport default compress;","map":{"version":3,"sources":["C:\\Users\\rarya\\OneDrive\\Desktop\\git hashcode\\AMS\\AMS Client\\node_modules\\compressed-json\\lib\\compress.js"],"names":["stringConverter","options","reservedKeys","reservedValues","MIN_SHARE_STRING_LENGTH","MAX_SHARE_STRING_LENGTH","keysDict","knownValuesDict","pointers","keys","wrappers","shortKeyFor","key","keyIndex","shortKey","stringValueFor","canBeShared","value","index","pointer","keyPath","shared","convert","Array","arr","values","type","compressed","Object","converted","lastKey","wrapper","K","P","_","compress","JSON","module"],"mappings":"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","sourcesContent":["/**\n * @memberof module:compressed-json\n * @function compress\n * @param {Object} data\n * @param {Object} [options={}] - Optional settings\n */\n'use strict'\n\nconst stringConverter = require('./converters/stringConverter')\n\n/** @lends module:compressed-json.compress */\nfunction compress (src, options = {}) {\n  const {\n    reservedKeys = [],\n    reservedValues = [],\n  } = options\n  const MIN_SHARE_STRING_LENGTH = 4\n  const MAX_SHARE_STRING_LENGTH = 512\n  const keysDict = {}\n  const knownValuesDict = {}\n  const pointers = []\n  const keys = []\n  const wrappers = {}\n  const shortKeyFor = (key) => {\n    if (key in keysDict) {\n      return keysDict[key]\n    }\n    const keyIndex = keys.length\n    const shortKey = (keyIndex).toString(36)\n    keysDict[key] = shortKey\n    keys.push(key)\n    return shortKey\n  }\n  reservedKeys.forEach(reservedKey=> shortKeyFor(reservedKey))\n  const stringValueFor = (value, keyPath) => {\n    const canBeShared = MIN_SHARE_STRING_LENGTH <= value.length &&\n      value.length <= MAX_SHARE_STRING_LENGTH\n    if (canBeShared) {\n      if (value in knownValuesDict) {\n        if (knownValuesDict[value].shared) {\n          return knownValuesDict[value].pointer\n        }\n        const index = pointers.length\n        pointers.push(value)\n        const pointer = stringConverter.toPointer(index)\n        knownValuesDict[value].pointer = pointer\n        knownValuesDict[value].shared = true\n        return pointer\n      }\n    }\n    knownValuesDict[value] = { keyPath, shared: false, pointer: null }\n    return stringConverter.toEscaped(value)\n  }\n  reservedValues.forEach(reservedValue => stringValueFor(reservedValue))\n  const convert = (values, { keyPath = '' } = {}) => {\n    if (Array.isArray(values)) {\n      const arr = values.map((v, i) => convert(v, { keyPath: [keyPath, i].join('/') }))\n      wrappers[keyPath] = arr\n      return arr\n    }\n    if (values === null) {\n      return null\n    }\n    const type = typeof values\n    switch (type) {\n      case 'function':\n        return null\n      case 'object': {\n        if (values instanceof Date) {\n          return values.toJSON()\n        }\n        const compressed = {}\n        const keys = Object.keys(values)\n        for (const key of keys) {\n          const value = values[key]\n          const shortKey = shortKeyFor(key)\n          compressed[shortKey] = convert(value, { keyPath: [keyPath, shortKey].join('/') })\n        }\n        wrappers[keyPath] = compressed\n        return compressed\n      }\n      case 'string':\n        return stringValueFor(values, keyPath)\n      default:\n        return values\n    }\n  }\n  const converted = convert(src)\n  for (const { pointer, shared, keyPath } of Object.values(knownValuesDict)) {\n    if (shared && keyPath) {\n      const keys = keyPath.split('/')\n      const lastKey = keys.pop()\n      const wrapper = wrappers[keys.join('/')]\n      wrapper[lastKey] = pointer\n    }\n  }\n  const K = keys.slice(reservedKeys.length)\n  const P = pointers.slice(reservedValues.length)\n  return {\n    ...(K.length > 0) ? { K } : {},\n    ...(P.length > 0 ? { P } : {}),\n    _: converted,\n  }\n}\n\ncompress.toString = function compressToString (data, options={}) {\n  const compressed = compress(data, options)\n  return JSON.stringify(compressed)\n}\n\nmodule.exports = compress\n"]},"metadata":{},"sourceType":"module"}